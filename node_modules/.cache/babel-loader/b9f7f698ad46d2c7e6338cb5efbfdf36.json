{"ast":null,"code":"import _regeneratorRuntime from \"/home/emanuel/Desktop/ReactLearning/articlesreact/node_modules/@babel/runtime/regenerator\";\n\nvar _marked =\n/*#__PURE__*/\n_regeneratorRuntime.mark(fetchToken),\n    _marked2 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(tokenSaga);\n\nimport { call, put, takeLatest } from 'redux-saga/effects';\nimport { FETCH_TOKEN, TOKEN_FETCH_SUCCEEDED, TOKEN_FETCH_ERROR } from '../constants/action-types-auth'; // constante com o endereço da API\n\nimport { TOKEN_ENDPOINT, CLIENT_ID, REDIRECT_URI, SECRET } from \"../constants/services\"; // função para obter o Access Token que irá identificar o utilizador\n// tem de ser um pedido do tipo POST com todos os parâmetros no BODY\n\nfunction fetchAll(code) {\n  console.log('fetch token ', code.payload); // Construção do objeto de BODY do pedido\n\n  var data = new URLSearchParams();\n  var url_params = [['client_id', CLIENT_ID], ['redirect_uri', REDIRECT_URI], ['grant_type', 'authorization_code'], ['client_secret', SECRET], ['code', code.payload]];\n\n  for (var _i = 0; _i < url_params.length; _i++) {\n    var pair = url_params[_i];\n    data.append(pair[0], pair[1]);\n  }\n\n  console.log('data', JSON.stringify(data)); // pedido para obter o access token\n\n  return fetch(TOKEN_ENDPOINT, {\n    method: 'post',\n    body: data\n  }).then(function (response) {\n    return response.json();\n  });\n} // worker Saga: irá ser invocada quando ocorrer um FETCH_TOKEN action\n\n\nfunction fetchToken(code) {\n  var token;\n  return _regeneratorRuntime.wrap(function fetchToken$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return call(fetchAll, code);\n\n        case 3:\n          token = _context.sent;\n          _context.next = 6;\n          return put({\n            type: TOKEN_FETCH_SUCCEEDED,\n            payload: token\n          });\n\n        case 6:\n          _context.next = 12;\n          break;\n\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](0);\n          _context.next = 12;\n          return put({\n            type: TOKEN_FETCH_ERROR,\n            message: _context.t0.message\n          });\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, this, [[0, 8]]);\n}\n/*\n  Utilizar a função takeLatest para evitar multiplas chamadas à API\n  Caso ocorram múltiplas chamadas irá ignorar todas à excepção da última\n*/\n\n\nfunction tokenSaga() {\n  return _regeneratorRuntime.wrap(function tokenSaga$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          console.log('token saga init');\n          _context2.next = 3;\n          return takeLatest(FETCH_TOKEN, fetchToken);\n\n        case 3:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, this);\n}\n\nexport default tokenSaga;","map":{"version":3,"sources":["/home/emanuel/Desktop/ReactLearning/articlesreact/src/js/sagas/auth.js"],"names":["fetchToken","tokenSaga","call","put","takeLatest","FETCH_TOKEN","TOKEN_FETCH_SUCCEEDED","TOKEN_FETCH_ERROR","TOKEN_ENDPOINT","CLIENT_ID","REDIRECT_URI","SECRET","fetchAll","code","console","log","payload","data","URLSearchParams","url_params","pair","append","JSON","stringify","fetch","method","body","then","response","json","token","type","message"],"mappings":";;;;yBA+BUA,U;;;yBAgBAC,S;;AA/CV,SAASC,IAAT,EAAeC,GAAf,EAAoBC,UAApB,QAAsC,oBAAtC;AACA,SAASC,WAAT,EAAsBC,qBAAtB,EAA6CC,iBAA7C,QAAsE,gCAAtE,C,CAEA;;AACA,SAAQC,cAAR,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiDC,MAAjD,QAA8D,uBAA9D,C,CAEA;AACA;;AACA,SAASC,QAAT,CAAkBC,IAAlB,EAAwB;AAEpBC,EAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EAA4BF,IAAI,CAACG,OAAjC,EAFoB,CAIpB;;AACA,MAAMC,IAAI,GAAG,IAAIC,eAAJ,EAAb;AACA,MAAIC,UAAU,GAAG,CACb,CAAC,WAAD,EAAcV,SAAd,CADa,EAEb,CAAC,cAAD,EAAgBC,YAAhB,CAFa,EAGb,CAAC,YAAD,EAAc,oBAAd,CAHa,EAIb,CAAC,eAAD,EAAiBC,MAAjB,CAJa,EAKb,CAAC,MAAD,EAASE,IAAI,CAACG,OAAd,CALa,CAAjB;;AAQA,wBAAmBG,UAAnB,eAA+B;AAA1B,QAAMC,IAAI,GAAID,UAAJ,IAAV;AACDF,IAAAA,IAAI,CAACI,MAAL,CAAYD,IAAI,CAAC,CAAD,CAAhB,EAAqBA,IAAI,CAAC,CAAD,CAAzB;AACH;;AACDN,EAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ,EAAoBO,IAAI,CAACC,SAAL,CAAeN,IAAf,CAApB,EAjBoB,CAkBpB;;AACA,SAAOO,KAAK,CAAChB,cAAD,EAAiB;AAACiB,IAAAA,MAAM,EAAE,MAAT;AAAiBC,IAAAA,IAAI,EAAET;AAAvB,GAAjB,CAAL,CAAoDU,IAApD,CAAyD,UAAAC,QAAQ;AAAA,WAAIA,QAAQ,CAACC,IAAT,EAAJ;AAAA,GAAjE,CAAP;AACH,C,CAED;;;AACA,SAAU7B,UAAV,CAAqBa,IAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGsB,iBAAMX,IAAI,CAACU,QAAD,EAAWC,IAAX,CAAV;;AAHtB;AAGciB,UAAAA,KAHd;AAAA;AAKQ,iBAAM3B,GAAG,CAAC;AAAC4B,YAAAA,IAAI,EAAEzB,qBAAP;AAA8BU,YAAAA,OAAO,EAAEc;AAAvC,WAAD,CAAT;;AALR;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAQQ,iBAAM3B,GAAG,CAAC;AAAC4B,YAAAA,IAAI,EAAExB,iBAAP;AAA0ByB,YAAAA,OAAO,EAAE,YAAEA;AAArC,WAAD,CAAT;;AARR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;;;;;;AAIA,SAAU/B,SAAV;AAAA;AAAA;AAAA;AAAA;AACIa,UAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AADJ;AAEI,iBAAMX,UAAU,CAACC,WAAD,EAAcL,UAAd,CAAhB;;AAFJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA,eAAeC,SAAf","sourcesContent":["import { call, put, takeLatest } from 'redux-saga/effects'\nimport { FETCH_TOKEN, TOKEN_FETCH_SUCCEEDED, TOKEN_FETCH_ERROR } from '../constants/action-types-auth'\n\n// constante com o endereço da API\nimport {TOKEN_ENDPOINT, CLIENT_ID, REDIRECT_URI, SECRET} from \"../constants/services\";\n\n// função para obter o Access Token que irá identificar o utilizador\n// tem de ser um pedido do tipo POST com todos os parâmetros no BODY\nfunction fetchAll(code) {\n\n    console.log('fetch token ', code.payload);\n\n    // Construção do objeto de BODY do pedido\n    const data = new URLSearchParams();\n    let url_params = [\n        ['client_id', CLIENT_ID],\n        ['redirect_uri',REDIRECT_URI],\n        ['grant_type','authorization_code'],\n        ['client_secret',SECRET],\n        ['code', code.payload]\n    ];\n\n    for (const pair of url_params) {\n        data.append(pair[0], pair[1]);\n    }\n    console.log('data', JSON.stringify(data));\n    // pedido para obter o access token\n    return fetch(TOKEN_ENDPOINT, {method: 'post', body: data}).then(response => response.json(), );\n}\n\n// worker Saga: irá ser invocada quando ocorrer um FETCH_TOKEN action\nfunction* fetchToken(code) {\n    try {\n        // invocar a função para obter o access token\n        const token = yield call(fetchAll, code);\n        // assim que houver uma resposta da API, invoca a action, enviado o novo access token\n        yield put({type: TOKEN_FETCH_SUCCEEDED, payload: token});\n    } catch (e) {\n        // caso exista um erro, devolve a mensagem de erro\n        yield put({type: TOKEN_FETCH_ERROR, message: e.message});\n    }\n}\n\n/*\n  Utilizar a função takeLatest para evitar multiplas chamadas à API\n  Caso ocorram múltiplas chamadas irá ignorar todas à excepção da última\n*/\nfunction* tokenSaga() {\n    console.log('token saga init');\n    yield takeLatest(FETCH_TOKEN, fetchToken);\n}\n\nexport default tokenSaga;\n"]},"metadata":{},"sourceType":"module"}